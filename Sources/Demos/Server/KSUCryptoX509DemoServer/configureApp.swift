//
//  File.swift
//
//
//  Created by Jonathan Forbes on 03/10/2023.
//

import Vapor
import Fluent
import Dispatch
import Logging
import KernelSwiftServer
import KernelSwiftCommon
import NIOSSL

@main
enum KSUCryptoX509DemoServer {
    static func main() async throws {
        var env = try Environment.detect()
        let logLevel = try Logger.Level.detect(from: &env)
        #if canImport(Darwin)
        KernelSwiftCommon.bootstrapLogging("KSU", logLevel: logLevel)
        #else
        try LoggingSystem.bootstrap(from: &env)
        #endif
        let app = try await Application.initDI(&env)
        do {
            try await configureApp(app)
        } catch {
            app.logger.report(error: error)
            try? await app.asyncShutdown()
            throw error
        }
        try await app.execute()
        try await app.asyncShutdown()
    }
}

public func configureApp(_ app: Application, _ portOverride: Int? = nil) async throws {
    let port = portOverride ?? Environment.get("HTTP_PORT").flatMap(Int.init(_:)) ?? 8080
    app.http.server.configuration.port = port
    app.http.server.configuration.supportVersions = Set<HTTPVersionMajor>([.two])
    app.http.server.configuration.supportPipelining = true

    let serverRootCertificatePath = "Keys/DemoSSL/minica.pem"
    let serverCertificatePath = "Keys/DemoSSL/cert.pem"
    let serverPrivateKeyPath = "Keys/DemoSSL/key.pem"
    let dbRootCertificatePath = "Keys/DemoSSL/myCA.crt"
    let dbCertificatePath = "Keys/DemoSSL/postgresdb.crt"
    let dbPrivateKeyPath = "Keys/DemoSSL/postgresdb.key"
    
    guard
        let serverCertificate = try NIOSSLCertificate.fromPEMFile(serverCertificatePath).first,
        let serverRootCertificate = try NIOSSLCertificate.fromPEMFile(serverRootCertificatePath).first
    else {
        throw Abort(.internalServerError, reason: "Couldn't load server certificates")
    }
    
    var serverSSLConf: TLSConfiguration = try .makeServerConfiguration(
        certificateChain: [
            NIOSSLCertificateSource.certificate(serverCertificate),
            NIOSSLCertificateSource.certificate(serverRootCertificate)
        ],
        privateKey: .privateKey(.init(file: serverPrivateKeyPath, format: .pem))
    )
    
    // becuase there is no trusted system root CA?
    serverSSLConf.certificateVerification = .none
    app.http.server.configuration.tlsConfiguration = serverSSLConf
    
    // these seem to slide down the turnk to the root
    var dbSSLConf: TLSConfiguration = .makeClientConfiguration()
    guard
        let dbCertificate = try NIOSSLCertificate.fromPEMFile(dbCertificatePath).first,
        let dbRootCertificate = try NIOSSLCertificate.fromPEMFile(dbRootCertificatePath).first
    else {
        throw Abort(.internalServerError, reason: "Couldn't load database certificates")
    }
    
    dbSSLConf.certificateChain = .init([
        .certificate(dbCertificate),
        .certificate(dbRootCertificate)
    ])
    
    // private key generated by client before csr to CA-1?
    try dbSSLConf.privateKey = .privateKey(.init(file: dbPrivateKeyPath, format: .pem))
    // becuase there is no trusted system root CA?
    // or no dns?
    dbSSLConf.certificateVerification = .none
    let dbTimeout = 3
    app.logger.debug("using DB SSL config: \(dbSSLConf)")
    app.logger.notice("DB Initialisation Timeout (\(dbTimeout) \(dbTimeout == 1 ? "second" : "seconds"))")
    try await Task.sleep(for: .seconds(dbTimeout))

    app.databases.use(
        .postgres(
            configuration: .init(
                hostname: Environment.get("DATABASE_HOST") ?? "127.0.0.1",
                port: Environment.get("DATABASE_PORT").flatMap(Int.init(_:)) ?? 5432,
                username: "postgresdb",
                password: "postgresdb",
                database: "ksu_crypto_x509",
                tls: .require(try .init(configuration: dbSSLConf))
                //tls: .disable
            ),
            maxConnectionsPerEventLoop: 5,
            connectionPoolTimeout: .seconds(60),
            sqlLogLevel: .debug
        ),
        as: .psql
    )
    
    KernelServerPlatform.initialise(for: app)
    try await KernelNetworking.initialise(for: app)
    try await KernelTaskScheduler.initialise(for: app)
    try await KernelX509.initialise(
        for: app,
        withConfiguration: [
            (.defaultDatabaseID, DatabaseID.psql)
        ]
    )
    
    try await KernelCryptography.initialise(
        for: app,
        withConfiguration: [
            (.defaultDatabaseID, DatabaseID.psql)
        ]
    )
    
    KernelFluentModel.Migrations.prepare(on: app, for: .psql)
    KernelCryptography.Fluent.Migrations.prepare(on: app, for: .psql)
    KernelX509.Fluent.Migrations.prepare(on: app, for: .psql)
    
    try app.register(
        collection: DocumentationController(
            title: "KSU Crypto X509 Demo",
            contentColor: .init(fromHex: "#45586e"),
            collections: []
        )
    )
    
    try await app.autoMigrate()
}
